
module std.wide_arithmetic if endian == "little"

fn wide_

fn wide_bit_width(rhs : span[__builtin_limb]) -> __builtin_u64
{
    if (rhs.size() == 0) {
        return 0
    }

    let sign = __builtin_sra(rhs[rhs.size() - 1], sizeof(__builtin_limb) * 8 - 1)

    var i = rhs.size()
    for (; i != 0; --i) {
        var tmp = rhs[i - 1]
        if (tmp != sign) {
            if (sign != 0) {
                tmp = __builtin_invert(tmp);
            }

            var num_bits = (i : __builtin_u64) * sizeof(__builtin_limb) * 8
            return num_bits - __builtin_lcount_zero(tmp);
        }
    }

    return 0
}

/** Make a copy of a signed integer.
 *
 * The lhs is sign extended
 *
 * @note It is UNDEFINED BEHAVIOUR to copy a integer that does not fit the
 *       destination.
 * @param lhs The destination
 * @param rhs The source
 */
fn wide_copy(lhs : span[__builtin_limb], rhs : span[__builtin_limb])
{
    let size = __builtin_min(lhs.size(), rhs.size())

    var tmp = 0 : __builtin_limb
    var i = 0 : __builtin_u32
    for (; i != size; ++i) {
        tmp = lhs[i] = rhs[i]
    }

    // Sign extend rhs.
    tmp = __builtin_sra(tmp, sizeof(__builtin_limb) * 8 - 1)
    for (; i < lhs.size(); ++i) {
        lhs[i] = tmp
    }

    // Check overflow on truncation.
    for (; i < rhs.size(); ++i) {
        assert(rhs[i] == tmp)
    }
}

fn wide_inplace_add(lhs : span[__builtin_limb], rhs : span[__builtin_limb])
    pre(lhs.size() >= rhs.size())
{
    var c = 0 : __builtin_u1
    var i = 0 : __builtin_u32
    var tmp = 0 : __builtin_limb
    for (; i != rhs.size(); ++i) {
        tmp = rhs[i]
        lhs[i], c = __builtin_add_carry(lhs[i], tmp, c)
    }

    // Sign extend rhs.
    tmp = __builtin_sra(tmp, sizeof(tmp) * 8 - 1)
    for (; i != lhs.size(); ++i) {
        lhs[i], c = __builtin_add_carry(lhs[i], tmp, c)
    }
}

