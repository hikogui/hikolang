
module std.wide_arithmetic if endian == "little"

fn wide_sign(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size) -> __builtin_limb
{
    return __builtin_sra(rhs[size - 1], sizeof(__builtin_limb) * 8 - 1)
}

/** Count significant bits of an wide integer
 *
 * This counts the number of significant bits, exclusive sign bit.
 *
 * @param a A pointer to the signed wide integer to calculate the size for.
 * @param a_size The number of limbs in the wide integer.
 * @return The number of significant bit, excluding the sign bit.
 */
fn wide_bit_width(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size) -> __builtin_size
{
    if (a_size != 0) {
        let sign = wide_sign(a, a_size)

        for (var i = a_size; i != 0; --i) {
            let tmp = rhs[i - 1]
            if (tmp != sign) {
                let num_bits = i * sizeof(__builtin_limb) * 8
                return num_bits - __builtin_lcount_zero(tmp ^ sign)
            }
        }
    }

    return 0
}

/** Make a signed integer zero.
 *
 * @note The number will be truncated if the dst is smaller than src.
 * @note The number is sign extended if dst is larger than src.
 * @param r Destination for the copied integer.
 * @param r_size The number of limbs of the destination.
 */
fn wide_zero(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size)
{
    for (var i = 0 : __builtin_size; i != r_size; ++i) {
        r[i] = 0
    }
}

/** Make a copy of a signed integer.
 *
 * @note The number will be truncated if the dst is smaller than src.
 * @note The number is sign extended if dst is larger than src.
 * @param dst Destination for the copied integer.
 * @param dst_size The number of limbs of the destination.
 * @param src Source of the signed integer to be copied.
 * @param src_size The number of limbs of the source
 */
fn wide_copy(
    let dst : raw_ptr[__builtin_limb],
    let dst_size : __builtin_size,
    let src : raw_ptr[__builtin_limb],
    let src_size : __builtin_size)
{
    let src_sign = wide_sign(srd, src_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(src_size, dst_size); ++i) {
        dst[i] = src[i]
    }

    for (; i < dst_size; ++i) {
        dst[i] = src_sign
    }
}

/** NOT a signed wide integers.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 */
fn wide_not(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size); ++i) {
        r[i] = ~a[i]
    }

    for (; i < r_size; ++i) {
        r[i] = ~a_sign
    }
}

/** Negate a signed wide integers.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 */
fn wide_neg(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)

    var c = 1 : __builtin_u1
    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size); ++i) {
        r[i], c = __builtin_add_carry(~a[i], 0, c)
    }

    for (; i < r_size; ++i) {
        r[i], c = __builtin_add_carry(~a_sign, 0, c)
    }
}

/** AND two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_and(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size, b_size); ++i) {
        r[i] = a[i] & b[i]
    }

    for (; i < __builtin_min(r_size, b_size); ++i) {
        r[i] = a_sign & b[i]
    }

    for (; i < __builtin_min(r_size, a_size); ++i) {
        r[i] = a[i] & b_sign
    }

    for (; i < r_size; ++i) {
        r[i] = a_sign & b_sign
    }
}

/** OR two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_or(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size, b_size); ++i) {
        r[i] = a[i] | b[i]
    }

    for (; i < __builtin_min(r_size, b_size); ++i) {
        r[i] = a_sign | b[i]
    }

    for (; i < __builtin_min(r_size, a_size); ++i) {
        r[i] = a[i] | b_sign
    }

    for (; i < r_size; ++i) {
        r[i] = a_sign | b_sign
    }
}

/** OR two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_xor(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size, b_size); ++i) {
        r[i] = a[i] ^ b[i]
    }

    for (; i < __builtin_min(r_size, b_size); ++i) {
        r[i] = a_sign ^ b[i]
    }

    for (; i < __builtin_min(r_size, a_size); ++i) {
        r[i] = a[i] ^ b_sign
    }

    for (; i < r_size; ++i) {
        r[i] = a_sign ^ b_sign
    }
}



fn wide_sll(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : __builting_size)
{

}

/** Add two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @param c Carry input
 * @return Carry output
 */
fn wide_add(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size,
    var c : __builtin_u1 = 0)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size, b_size); ++i) {
        r[i], c = __builtin_add_carry(a[i], b[i], c)
    }

    for (; i < __builtin_min(r_size, b_size); ++i) {
        r[i], c = __builtin_add_carry(a_sign, b[i], c)
    }

    for (; i < __builtin_min(r_size, a_size); ++i) {
        r[i], c = __builtin_add_carry(a[i], b_sign, c)
    }

    for (; i < r_size; ++i) {
        r[i], c = __builtin_add_carry(a_sign, b_sign, c)
    }
}

/** Subtract two signed wide integers from each other.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @param c Borrow input
 */
fn wide_sub(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size,
    var c : __builtin_u1 = 0)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    for (; i != __builtin_min(r_size, a_size, b_size); ++i) {
        r[i], c = __builtin_sub_carry(a[i], b[i], c)
    }

    for (; i < __builtin_min(r_size, b_size); ++i) {
        r[i], c = __builtin_sub_carry(a_sign, b[i], c)
    }

    for (; i < __builtin_min(r_size, a_size); ++i) {
        r[i], c = __builtin_sub_carry(a[i], b_sign, c)
    }

    for (; i < r_size; ++i) {
        r[i], c = __builtin_sub_carry(a_sign, b_sign, c)
    }
}

/** Helper for wide_cmp().
 */
fn wide_cmp_limb(a : __builtin_limb, b : __builtin_limb, sign : __builtin_limb) -> __builtin_i8
{
    if (a == b) {
        return 0
    } else if (a < b) {
        return if (sign == 0) { -1 } else { 1 }
    } else {
        return if (sign == 0) { 1 } else { -1 }
    }
}

/** Compare two signed wide integers to each other.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @return -1: a < b, 0: a == b, 1: a > b
 */
fn wide_cmp(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
    -> __builtin_i8
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    if (a_sign != b_sign) {
        return if (a_sign == 0) { 1 } else { -1 }
    }

    let sign = a_sign
    var i = 0 : __builtin_size
    if (a_size > b_size) {
        for (i = a_size; i != b_size; --i) {
            if (let r = wide_cmp_limb(a[i - 1], sign, sign); r != 0) {
                return r
            }
        }
    } else {
        for (i = b_size; i != a_size; --i) {
            if (let r = wide_cmp_limb(sign, b[i - 1], sign); r != 0) {
                return r
            }
        }
    }

    for (; != 0; --i) {
        if (let r = wide_cmp_limb(a[i - 1], b[i - 1], sign); r != 0) {
            return r
        }
    }

    return 0
}

fn wide_mul(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    var a : raw_ptr[__builtin_limb],
    var a_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
{
    // With multiplication a smaller second operand is better.
    if (b_size > a_size) {
        swap(a_size, b_size)
        swap(a, b)
    }

    // Since we are doing positive multiplication, r needs to be zero.
    wide_zero(r, r_size)

    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)
    var b_tmp_c = b_sign != 0
    for (var b_i = 0 : __builtin_size; b_i != b_size; ++b_i) {
        var b_tmp, b_tmp_c = __builtin_add_carry(b[b_i] ^ b_sign, 0, b_tmp_c)

        var r_i = b_i
        var mul_carry = 0 : __builtin_limb
        var a_tmp_c = a_sign != 0
        for (var a_i = 0 : __builtin_size; a_i != a_size; ++a_i) {
            var a_tmp, a_tmp_c = __builtin_add_carry(a[a_i] ^ a_sign, 0, a_tmp_c)
            r[r_i], mul_carry = __builtin_fma(a_tmp, b_tmp, r[r_i], mul_carry)
            ++r_i
        }

        // Carry chain the rest of the accumulator.
        if (r_i < r_size) {
            r[r_i] = mul_carry
        }
    }

    if (a_sign != b_sign) {
        wide_neg(r, r_size, r, r_size)
    }
}

