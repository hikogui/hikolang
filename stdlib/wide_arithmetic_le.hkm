
module std.wide_arithmetic if endian == "little"

/** Low level arbitrary wide integer add.
 *
 * @param lhs Left hand side of the add operator (sign extended)
 * @param rhs Right hand side of the add operator (sign extended)
 * @param carry_in carry input
 * @param result The result of the add operator
 * @return carry_out carry output
 */
fn wide_add(let lhs : span[__builtin_limb], let rhs: span[__builtin_limb], let carry_in: __builtin_u1, let result: span[__builtin_limb])
    -> __builtin_u1
    pre(lhs.size() <= result.size())
    pre(rhs.size() <= result.size())
    maybe_unused
{
    let min_size = min(lhs.size(), rhs.size());

    var c = carry_in
    var i = 0 : __builtin_u32
    for (; i != min_size; ++i) {
        result[i], c = __builtin_add_carry(lhs[i], rhs[i], c)
    }

    let lhs_extend = if (lhs.size() != 0) { __builtin_sra(lhs.back(), sizeof(T) * 8 - 1) } else { 0 : T }
    let rhs_extend = if (rhs.size() != 0) { __builtin_sra(rhs.back(), sizeof(T) * 8 - 1) } else { 0 : T }

    if (lhs.size() >= rhs.size()) {
        for (; i != lhs.size(); ++i) {
            result[i], c = __builtin_add_carry(lhs[i], rhs_extend, c)
        }

    } else {
        for (; i != rhs.size(); ++i) {
            result[i], c = __builtin_add_carry(lhs_extend, rhs[i], c)
        }
    }

    for (; i != o.size(); ++i) {
        result[i], c = __builtin_add_carry(lhs_extend, rhs_extend, c)
    }

    return c
}

