
module std.wide_arithmetic if endian == "little"

/** Get the sign of a signed wide integer.
 *
 * @param a A pointer to the signed wide integer
 * @param a_size The number of limbs in @a a.
 * @return A limb with all bits set to '0' when positive and all bits set
 *         to '1' when negative.
 */
fn wide_sign(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size) -> __builtin_limb
{
    return __builtin_sra(a[a_size - 1], sizeof(__builtin_limb) * 8 - 1)
}

/** Count significant bits of an wide integer
 *
 * This counts the number of significant bits, exclusive sign bit.
 *
 * @param a A pointer to the signed wide integer to calculate the size for.
 * @param a_size The number of limbs in the wide integer.
 * @return The number of significant bit, excluding the sign bit.
 */
fn wide_bit_width(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size) -> __builtin_size
{
    if (a_size != 0) {
        let sign = wide_sign(a, a_size)

        for (var i = a_size; i != 0; --i) {
            let tmp = a[i - 1]
            if (tmp != sign) {
                let num_bits = i * sizeof(__builtin_limb) * 8
                return num_bits - __builtin_lcount_zero(tmp ^ sign)
            }
        }
    }

    return 0
}

/** Make a signed integer zero.
 *
 * @note The number will be truncated if the dst is smaller than src.
 * @note The number is sign extended if dst is larger than src.
 * @param r Destination for the copied integer.
 * @param r_size The number of limbs of the destination.
 */
fn wide_make_zero(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size)
{
    for (var i = 0 : __builtin_size; i != r_size; ++i) {
        r[i] = 0
    }
}

/** Make a copy of a signed integer.
 *
 * @note The number will be truncated if the dst is smaller than src.
 * @note The number is sign extended if dst is larger than src.
 * @param dst Destination for the copied integer.
 * @param dst_size The number of limbs of the destination.
 * @param src Source of the signed integer to be copied.
 * @param src_size The number of limbs of the source
 */
fn wide_copy(
    let dst : raw_ptr[__builtin_limb],
    let dst_size : __builtin_size,
    let src : raw_ptr[__builtin_limb],
    let src_size : __builtin_size)
{
    let src_sign = wide_sign(srd, src_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(src_size, dst_size)) {
        dst[i] = src[i]
        ++i
    }

    while (i != dst_size) {
        dst[i] = src_sign
        ++i
    }
}

/** Invert a signed wide integers.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 */
fn wide_inv(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size)) {
        r[i] = ~a[i]
        ++i
    }

    while (i != r_size) {
        r[i] = ~a_sign
        ++i
    }
}

/** Negate a signed wide integers.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 */
fn wide_neg(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)

    var c = 1 : __builtin_u1
    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size)) {
        r[i], c = __builtin_add_carry(~a[i], 0, c)
        ++i
    }

    while (i != r_size) {
        r[i], c = __builtin_add_carry(~a_sign, 0, c)
        ++i
    }
}

/** AND two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_and(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size, b_size)) {
        r[i] = a[i] & b[i]
        ++i
    }

    while (i != __builtin_min(r_size, b_size)) {
        r[i] = a_sign & b[i]
        ++i
    }

    // less-than check because b might be larger than a.
    while (i < __builtin_min(r_size, a_size)) {
        r[i] = a[i] & b_sign
        ++i
    }

    while (i != r_size) {
        r[i] = a_sign & b_sign
        ++i
    }
}

/** OR two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_or(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size, b_size)) {
        r[i] = a[i] | b[i]
        ++i
    }

    while (i != __builtin_min(r_size, b_size)) {
        r[i] = a_sign | b[i]
        ++i
    }

    // less-than check because b might be larger than a.
    while (i < __builtin_min(r_size, a_size)) {
        r[i] = a[i] | b_sign
        ++i
    }

    while (i != r_size) {
        r[i] = a_sign | b_sign
        ++i
    }
}

/** OR two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 */
fn wide_xor(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size, b_size)) {
        r[i] = a[i] ^ b[i]
        ++i
    }

    while (i != __builtin_min(r_size, b_size)) {
        r[i] = a_sign ^ b[i]
        ++i
    }

    // less-than check because b might be larger than a.
    while (i < __builtin_min(r_size, a_size)) {
        r[i] = a[i] ^ b_sign
        ++i
    }

    while (i != r_size) {
        r[i] = a_sign ^ b_sign
        ++i
    }

}


/** Inplace SLL (Shift Left Logical) a wide integer
 *
 * @param a Integer to shift
 * @param a_size Number of limbs of @a a
 * @param b Number of bits to shift
 */
fn wide_inplace_sll(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : __builtin_size)
{
    let limb_width = sizeof(__builtin_limb) * 8
    let num_limbs_to_shift = b / limb_width
    let num_bits_to_shift = b % limb_width

    var i = a_size
    while (i > num_limbs_to_shift + 1) {
        let hi = a[i - 1 - num_limbs_to_shift] << num_bits_to_shift
        let lo = a[i - 2 - num_limbs_to_shift] >> (limb_width - num_bits_to_shift)
        a[i - 1] = hi | lo
        --i
    }

    if (i > num_limbs_to_shift) {
        a[i - 1] = a[i - 1 - num_limbs_to_shift] << num_bits_to_shift
        --i
    }

    while (i != 0) {
        a[i - 1] = 0
        --i
    }
}

/** Add two signed wide integers together.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @param c Carry input
 * @return Carry output
 */
fn wide_add(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size,
    var c : __builtin_u1 = 0)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size, b_size)) {
        r[i], c = __builtin_add_carry(a[i], b[i], c)
        ++i
    }

    while (i != __builtin_min(r_size, b_size)) {
        r[i], c = __builtin_add_carry(a_sign, b[i], c)
        ++i
    }

    // less-than check because b might be larger than a.
    while (i < __builtin_min(r_size, a_size)) {
        r[i], c = __builtin_add_carry(a[i], b_sign, c)
        ++i
    }

    while (i != r_size) {
        r[i], c = __builtin_add_carry(a_sign, b_sign, c)
        ++i
    }
}

/** Subtract two signed wide integers from each other.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param r The result.
 * @param r_size Size of @a r.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @param c Borrow input
 */
fn wide_sub(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size,
    var c : __builtin_u1 = 0)
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    var i = 0 : __builtin_size
    while (i != __builtin_min(r_size, a_size, b_size)) {
        r[i], c = __builtin_sub_carry(a[i], b[i], c)
        ++i
    }

    while (i != __builtin_min(r_size, b_size)) {
        r[i], c = __builtin_sub_carry(a_sign, b[i], c)
        ++i
    }

    // less-than check because b might be larger than a.
    while (i < __builtin_min(r_size, a_size)) {
        r[i], c = __builtin_sub_carry(a[i], b_sign, c)
        ++i
    }

    while (i != r_size) {
        r[i], c = __builtin_sub_carry(a_sign, b_sign, c)
        ++i
    }
}

/** Helper for wide_cmp().
 */
fn wide_cmp_limb(a : __builtin_limb, b : __builtin_limb, sign : __builtin_limb) -> __builtin_i8
{
    if (a == b) {
        return 0
    } else if (a < b) {
        return if (sign == 0) { -1 } else { 1 }
    } else {
        return if (sign == 0) { 1 } else { -1 }
    }
}

/** Compare two signed wide integers to each other.
 *
 * @note If @a a_size is less than @a r_size, @a a will be sign extended.
 * @note If @a b_size is less than @a r_size, @a b will be sign extended.
 * @note If @a a_size or @a b_size is smaller than @a r_size, then @a a or @a b will be truncated.
 * @param a The left hand side
 * @param a_size Size of @a a.
 * @param b The right hand side
 * @param b_size Size of @b b.
 * @return -1: a < b, 0: a == b, 1: a > b
 */
fn wide_cmp(
    let a : raw_ptr[__builtin_limb],
    let a_size : __builtin_size,
    let b : raw_ptr[__builtin_limb],
    let b_size : __builtin_size)
    -> __builtin_i8
{
    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)

    if (a_sign != b_sign) {
        return if (a_sign == 0) { 1 } else { -1 }
    }

    let sign = a_sign
    var i = 0 : __builtin_size
    if (a_size > b_size) {
        for (i = a_size; i != b_size; --i) {
            if (let r = wide_cmp_limb(a[i - 1], sign, sign); r != 0) {
                return r
            }
        }
    } else {
        for (i = b_size; i != a_size; --i) {
            if (let r = wide_cmp_limb(sign, b[i - 1], sign); r != 0) {
                return r
            }
        }
    }

    while (i != 0) {
        if (let r = wide_cmp_limb(a[i - 1], b[i - 1], sign); r != 0) {
            return r
        }
        --i
    }

    return 0
}

fn wide_mul(
    let r : raw_ptr[__builtin_limb],
    let r_size : __builtin_size,
    var a : raw_ptr[__builtin_limb],
    var a_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
{
    // With multiplication a smaller second operand is better.
    if (b_size > a_size) {
        swap(a_size, b_size)
        swap(a, b)
    }

    // Since we are doing positive multiplication, r needs to be zero.
    wide_zero(r, r_size)

    let a_sign = wide_sign(a, a_size)
    let b_sign = wide_sign(b, b_size)
    var b_tmp_c = b_sign != 0
    for (var b_i = 0 : __builtin_size; b_i != b_size; ++b_i) {
        var b_tmp, b_tmp_c = __builtin_add_carry(b[b_i] ^ b_sign, 0, b_tmp_c)

        var r_i = b_i
        var mul_carry = 0 : __builtin_limb
        var a_tmp_c = a_sign != 0
        for (var a_i = 0 : __builtin_size; a_i != a_size; ++a_i) {
            var a_tmp, a_tmp_c = __builtin_add_carry(a[a_i] ^ a_sign, 0, a_tmp_c)
            r[r_i], mul_carry = __builtin_fma(a_tmp, b_tmp, r[r_i], mul_carry)
            ++r_i
        }

        // Carry chain one further into the accumulator.
        // Since the limbs in the accumulator register has not gone this far
        // we do not need to ripple carry.
        if (r_i < r_size) {
            r[r_i] = mul_carry
        }
    }

    if (a_sign != b_sign) {
        wide_neg(r, r_size, r, r_size)
    }
}

fn wide_div_zero(
    let rd : raw_ptr[__builtin_limb],
    let rd_size : __builtin_size,
    let rm : raw_ptr[__builtin_limb],
    let rm_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
{
    if (wide_is_zero(b, b_size)) {
        return 1
    }

    for (var i = 0 : __builtin_size; i != rd_size; ++i) {
        rd[0] = 0
    }
    for (var i = 0 : __builtin_size; i != rm_size; ++i) {
        rm[0] = 0
    }

    return 0
}

fn wide_div_fast(
    let rd : raw_ptr[__builtin_limb],
    let rd_size : __builtin_size,
    let rm : raw_ptr[__builtin_limb],
    let rm_size : __builtin_size,
    var a : raw_ptr[__builtin_limb],
    var a_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
    -> __builtin_u1
{
    if (b[0] == 0) {
        return 1;
    }
    rd[0], rm[0] = __builtin_idivmod(a[0], b[0])

    let rd_sign = __builtin_sra(rd[0], sizeof(__builtin_limb) * 8 - 1)
    for (var i = 1 : __builtin_size; i != rd_size; ++i) {
        rd[i] = rd_sign
    }

    let rm_sign = __builtin_sra(rm[0], sizeof(__builtin_limb) * 8 - 1)
    for (var i = 1 : __builtin_size; i != rm_size; ++i) {
        rd[i] = rm_sign
    }

    return 0
}

fn wide_div_slow(
    let rd : raw_ptr[__builtin_limb],
    let rd_size : __builtin_size,
    let rm : raw_ptr[__builtin_limb],
    let rm_size : __builtin_size,
    var a : raw_ptr[__builtin_limb],
    var a_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
    -> __builtin_u1
{
}

fn wide_div(
    let rd : raw_ptr[__builtin_limb],
    let rd_size : __builtin_size,
    let rm : raw_ptr[__builtin_limb],
    let rm_size : __builtin_size,
    var a : raw_ptr[__builtin_limb],
    var a_size : __builtin_size,
    var b : raw_ptr[__builtin_limb],
    var b_size : __builtin_size)
    -> __builtin_u1
{
    if (b_size == 0) {
        return 1

    } else if (a_size == 0) {
        return wide_div_zero(rd, rd_size, rm, rm_size, b, b_size)

    } else if (b_size == 1 and a_size == 1) {
        return wide_div_fast(rd, rd_size, rm, rm_size, a, a_size, b, b_size)

    } else {
        return wide_div_slow(rd, rd_size, rm, rm_size, a, a_size, b, b_size)
    }
}
